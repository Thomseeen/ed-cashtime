// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using EdCashtime;
//
//    var commodities = Commodities.FromJson(jsonString);

namespace EdCashtime {
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;
    using J = Newtonsoft.Json.JsonPropertyAttribute;
    using R = Newtonsoft.Json.Required;
    using N = Newtonsoft.Json.NullValueHandling;

    public partial class Commodities {
        [J("$schemaRef", Required = R.Always)] public string SchemaRef { get; set; }
        [J("header", Required = R.Always)] public Header Header { get; set; }
        [J("message", Required = R.Always)] public Message Message { get; set; }
    }

    public partial class Header {
        [J("gatewayTimestamp", Required = R.DisallowNull, NullValueHandling = N.Ignore)] public DateTimeOffset? GatewayTimestamp { get; set; } // Timestamp upon receipt at the gateway. If present, this property will be overwritten by; the gateway; submitters are not intended to populate this property.
        [J("softwareName", Required = R.Always)] public string SoftwareName { get; set; }
        [J("softwareVersion", Required = R.Always)] public string SoftwareVersion { get; set; }
        [J("uploaderID", Required = R.Always)] public string UploaderId { get; set; }
    }

    public partial class Message {
        [J("commodities", Required = R.Always)] public Commodity[] Commodities { get; set; }  // Commodities returned by the Companion API, with illegal commodities omitted
        [J("economies", Required = R.DisallowNull, NullValueHandling = N.Ignore)] public Economy[] Economies { get; set; }
        [J("horizons", Required = R.DisallowNull, NullValueHandling = N.Ignore)] public bool? Horizons { get; set; }           // Whether the sending Cmdr has a Horizons pass.
        [J("marketId", Required = R.Always)] public long MarketId { get; set; }
        [J("odyssey", Required = R.DisallowNull, NullValueHandling = N.Ignore)] public bool? Odyssey { get; set; }            // Whether the sending Cmdr has an Odyssey expansion.
        [J("prohibited", Required = R.DisallowNull, NullValueHandling = N.Ignore)] [JsonConverter(typeof(DecodeArrayConverter))] public string[] Prohibited { get; set; }
        [J("stationName", Required = R.Always)] [JsonConverter(typeof(MinMaxLengthCheckConverter))] public string StationName { get; set; }
        [J("systemName", Required = R.Always)] [JsonConverter(typeof(MinMaxLengthCheckConverter))] public string SystemName { get; set; }
        [J("timestamp", Required = R.Always)] public DateTimeOffset Timestamp { get; set; }
    }

    public partial class Commodity {
        [J("buyPrice", Required = R.Always)] public long BuyPrice { get; set; }           // Price to buy from the market
        [J("demand", Required = R.Always)] public long Demand { get; set; }
        [J("demandBracket", Required = R.Always)] public LevelType DemandBracket { get; set; }
        [J("meanPrice", Required = R.Always)] public long MeanPrice { get; set; }
        [J("name", Required = R.Always)] [JsonConverter(typeof(MinMaxLengthCheckConverter))] public string Name { get; set; }             // Symbolic name as returned by the Companion API
        [J("sellPrice", Required = R.Always)] public long SellPrice { get; set; }          // Price to sell to the market
        [J("statusFlags", Required = R.DisallowNull, NullValueHandling = N.Ignore)] [JsonConverter(typeof(DecodeArrayConverter))] public string[] StatusFlags { get; set; }
        [J("stock", Required = R.Always)] public long Stock { get; set; }
        [J("stockBracket", Required = R.Always)] public LevelType StockBracket { get; set; }
    }

    public partial class Economy {
        [J("name", Required = R.Always)] [JsonConverter(typeof(MinMaxLengthCheckConverter))] public string Name { get; set; }       // Economy type as returned by the Companion API
        [J("proportion", Required = R.Always)] public double Proportion { get; set; }
    }

    /// <summary>Note: A value of "" indicates that the commodity is not normally sold/purchased at this; station, but is currently temporarily for sale/purchase</summary>
    public partial struct LevelType {
        public double? Double;
        public long? Integer;
        public string String;

        public static implicit operator LevelType(double Double) => new LevelType { Double = Double };
        public static implicit operator LevelType(long Integer) => new LevelType { Integer = Integer };
        public static implicit operator LevelType(string String) => new LevelType { String = String };
    }

    public partial class Commodities {
        public static Commodities FromJson(string json) => JsonConvert.DeserializeObject<Commodities>(json, EdCashtime.Converter.Settings);
    }

    public static class Serialize {
        public static string ToJson(this Commodities self) => JsonConvert.SerializeObject(self, EdCashtime.Converter.Settings);
    }

    internal static class Converter {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                LevelTypeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class LevelTypeConverter : JsonConverter {
        public override bool CanConvert(Type t) => t == typeof(LevelType) || t == typeof(LevelType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer) {
            switch (reader.TokenType) {
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long>(reader);
                    return new LevelType { Integer = integerValue };
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new LevelType { Double = doubleValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new LevelType { String = stringValue };
            }
            throw new Exception("Cannot unmarshal type LevelType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer) {
            var value = (LevelType)untypedValue;
            if (value.Integer != null) {
                serializer.Serialize(writer, value.Integer.Value);
                return;
            }
            if (value.Double != null) {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }
            if (value.String != null) {
                serializer.Serialize(writer, value.String);
                return;
            }
            throw new Exception("Cannot marshal type LevelType");
        }

        public static readonly LevelTypeConverter Singleton = new LevelTypeConverter();
    }

    internal class MinMaxLengthCheckConverter : JsonConverter {
        public override bool CanConvert(Type t) => t == typeof(string);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer) {
            var value = serializer.Deserialize<string>(reader);
            if (value.Length >= 1) {
                return value;
            }
            throw new Exception("Cannot unmarshal type string");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer) {
            var value = (string)untypedValue;
            if (value.Length >= 1) {
                serializer.Serialize(writer, value);
                return;
            }
            throw new Exception("Cannot marshal type string");
        }

        public static readonly MinMaxLengthCheckConverter Singleton = new MinMaxLengthCheckConverter();
    }

    internal class DecodeArrayConverter : JsonConverter {
        public override bool CanConvert(Type t) => t == typeof(string[]);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer) {
            reader.Read();
            var value = new List<string>();
            while (reader.TokenType != JsonToken.EndArray) {
                var converter = MinMaxLengthCheckConverter.Singleton;
                var arrayItem = (string)converter.ReadJson(reader, typeof(string), null, serializer);
                value.Add(arrayItem);
                reader.Read();
            }
            return value.ToArray();
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer) {
            var value = (string[])untypedValue;
            writer.WriteStartArray();
            foreach (var arrayItem in value) {
                var converter = MinMaxLengthCheckConverter.Singleton;
                converter.WriteJson(writer, arrayItem, serializer);
            }
            writer.WriteEndArray();
            return;
        }

        public static readonly DecodeArrayConverter Singleton = new DecodeArrayConverter();
    }
}
